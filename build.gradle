apply plugin: 'com.android.application'

description = 'OnOpenDevice'
version = loadVersion()

ext.tagName = 'ood'
ext.appMinSdkVersion = '9'
ext.appTargetSdkVersion = '23'
ext.androidBuildToolsVersion = '23'
ext.targetSdkVersion = 23
ext.androidSupportVersion = '22.1.0'
ext.gsonVersion = '2.3.1'

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:1.3.1'
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

dependencies {
    compile 'com.android.support:appcompat-v7:20.0.0'
    compile "com.google.code.gson:gson:${gsonVersion}"
}

android {
    compileSdkVersion targetSdkVersion
    buildToolsVersion androidBuildToolsVersion
    useLibrary 'org.apache.http.legacy'

    defaultConfig {
        applicationId "org.ledain.ood"
        minSdkVersion 15
        targetSdkVersion targetSdkVersion
        versionCode 4
        versionName version
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
        debug {
            zipAlignEnabled false
        }
    }
    dexOptions {
        //incremental true
    }

    lintOptions {
        abortOnError false
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }

    signingConfigs {
        release {
            storeFile file('signing/release.keystore')
            storePassword 'android'
            keyPassword 'android'
            keyAlias 'androiddebugkey'
        }
    }

    buildTypes {
        release {
            signingConfig signingConfigs.release
        }
    }
}

/**
 * Generate gradle wrapper
 * (updates "distributionUrl" in /gradle/wrapper/gradle-wrapper.properties and installs it)
 */
task wrapper(type: Wrapper) {
    gradleVersion = '2.2.1'
}

/**
 * Load version from version.properties file
 * Version will be marked as -SNAPSHOT if there are no tagRelease task in startParameters
 * @return
 */
def loadVersion() {
    def versionPropertiesFile = file("${project.projectDir}/version.properties")
    println "reading file: ${versionPropertiesFile}"
    if (versionPropertiesFile.canRead()) {
        def Properties versionProperties = new Properties()
        versionProperties.load(new FileInputStream(versionPropertiesFile))
        def major = versionProperties['major'].toInteger()
        def minor = versionProperties['minor'].toInteger()
        def build = versionProperties['build'].toInteger()
        def patch = versionProperties['patch']
        if (!patch.equals('')) {
            patch = patch.toInteger()
        }

        def release = gradle.startParameter.taskNames.contains("tagRelease")
        def tag = versionProperties['tag'].toString()

        if(tag.equals('null')) {
            tag = ''
        }
        else {
            tag = "-${tag}"
        }
        if (!patch.equals('')) {
            patch = ".${patch}"
        }
        def projectVersion = "${major}.${minor}.${build}${patch}${tag}${release ? '' : '-SNAPSHOT'}"
        println "projectVersion: ${projectVersion}"
        return projectVersion
    } else {
        println "unable to find file: ${versionPropertiesFile}"
        throw new GradleException("Could not read version.properties!")
    }
}


// ----------------------------------------------------------------------------------------------------

/**
 * Create the time stamp
 * @return integer value for timestamp
 */
def getTimeStamp() {
    def date = new Date()
    def formattedDate = date.format('yyMMddHHmm')
    return formattedDate as Integer
}

def getGradleUserProperty(key) {
    def path = "/home/devtools/.m2/gradle-user.txt"
    if(! new File(path).exists()) {
        path = "${project.projectDir}/gradle-user.txt"
    }

    if(new File(path).exists()) {
        def props = new Properties()
        new File(path).withInputStream {
            stream -> props.load(stream)
        }
        return props[key]
    } else {
        return ""
    }
}

def getPublisherUserName() {
    return getGradleUserProperty("publisherUsername")
}

def getPublisherPassword() {
    return getGradleUserProperty("publisherPassword")
}


def getPublishingRepository() {
    if("".equals(getPublisherUserName())) {
        String m2path;
        if(!"".equals(System.env.USERPROFILE))
            m2path = System.env.USERPROFILE
        else if(!"".equals(System.env.HOME))
            m2path = System.env.HOME
        else
            return ""
        if (m2path == null) {
            return ""
        }
        return "file://${m2path.replaceAll( "\\\\", "/")}/.m2/repository/"
    } else if(version.contains("SNAPSHOT")) {
        return snapshotPublish
    } else {
        return releasePublish
    }
}

/**
 * Tag release build in svn
 */
task tagRelease(type: Exec) {
    if (!version.contains("SNAPSHOT")) {
        executable 'svn'
        args 'copy',
                "${projectLocation}/trunk",
                "${projectLocation}/tags/${tagName}-${version}",
                '-m',
                "[gradle-release]   copy for tag ${tagName}-${version}"
    }
}

/**
 * Check if any dependency has a SNAPSHOT word in the version
 * That task should be run before release
 */
task checkSnapshotDependencies<< {
    def matcher = { Dependency d -> d.version?.contains('SNAPSHOT') }
    def collector = { Dependency d -> "${d.group ?: ''}:${d.name}:${d.version ?: ''}" }

    def message = ""

    project.allprojects.each { project ->
        def snapshotDependencies = [] as Set
        project.configurations.each { cfg ->
            snapshotDependencies += cfg.dependencies?.matching(matcher)?.collect(collector)
        }
        if (snapshotDependencies.size() > 0) {
            message += "\n\t${project.name}: ${snapshotDependencies}"
        }
    }

    if (message) {
        message = "Snapshot dependencies detected: ${message}"
        throw new GradleException(message)
    }
}

/**
 * Task for committing changed version.properties file
 * Must be run after increaseVersionForNextRelease task
 * For more info please see prepareForNextRelease task
 */
task commitVersionProperties(type: Exec) {
    executable 'svn'
    args 'commit',
            "${project.rootDir}/version.properties",
            '-m',
            '[gradle-release] prepare for next development iteration'
}

/**
 * Task for increasing version number
 * Needs to be called after release
 * If tag value isn't null we not going to increase version number
 * For more info please see prepareForNextRelease
 */
task increaseVersionForNextRelease<< {
    def versionPropertiesFile = file("${project.rootDir}/version.properties")
    if (versionPropertiesFile.canRead()) {
        def Properties versionProperties = new Properties()
        versionProperties.load(new FileInputStream(versionPropertiesFile))
        def major = versionProperties['major'].toInteger()
        def minor = versionProperties['minor'].toInteger()

        def build = versionProperties['build'].toInteger()
        def patch = versionProperties['patch']
        if (!patch.equals('')) {
            patch = patch.toInteger()
        }

        def tag = versionProperties['tag'].toString()
        if(!tag.equals('null')) {
            tag = 'null'
            versionProperties.put('tag', tag)
        }
        else if (!patch.equals('')) {
            patch += 1
        }
        else {
            build += 1
        }

        versionProperties.put('build', build as String)
        if (!patch.equals('')) {
            versionProperties.put('patch', patch as String)
        }
        versionProperties.store(versionPropertiesFile.newWriter(), null)

        def version = "${major}.${minor}.${build}"
        if (!patch.equals('')) {
            version += ".${patch}"
        }
        println "    new version: ${version}"
    } else {
        throw new GradleException("Could not read version.properties!")
    }
}

/**
 * Combined task for increasing version and committing it to svn
 */
task prepareForNextRelease(dependsOn: [increaseVersionForNextRelease, commitVersionProperties])<< { }
commitVersionProperties.mustRunAfter increaseVersionForNextRelease

